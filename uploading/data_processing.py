import requests
from collections import OrderedDict
import html
from bs4 import BeautifulSoup
from .config import *

from .structure import lst_category, ITEM, lst_photos, lst_param


def creating_items_table(item_tags, schema_name):
    items_columns = ''.join([i + ' text, ' for i in item_tags])
    db.execute(f"create table {schema_name}.items ("
               f"TransactionID int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, {items_columns[:-2]})")
    conn.commit()


def item_pars(all_products, schema_name, funk_tags):
    crossing_photo = list(set(funk_tags) & set(lst_photos))
    for cross_photo in crossing_photo:
        funk_tags.remove(cross_photo)
    crossing_params = list(set(funk_tags) & set(lst_param))
    for cross_param in crossing_params:
        funk_tags.remove(cross_param)
    funk_tags.insert(0, "primary_key")
    creating_items_table(funk_tags, schema_name)
    result_dictionary = {}
    primary_key = 0
    for product in all_products:
        primary_key += 1
        for tag in funk_tags:
            result_dictionary['primary_key'] = str(primary_key)
            if tag == 'item_id':
                result_dictionary[f"{tag}"] = product.get("id")
            else:
                variable = product.find(f"{tag}")
                if variable == None:
                    variable = ''
                    result_dictionary[f"{tag}"] = variable
                else:
                    result_dictionary[f"{tag}"] = html.escape(variable.get_text())
        items_tags = (', '.join(list(result_dictionary.keys())))
        items_values = [tuple(result_dictionary.values())]
        result_val = '%s, ' * len(items_values[0])
        sql = f"insert into {schema_name}.items ({items_tags}) values({result_val[:-2]})"
        db.executemany(sql, items_values)
        conn.commit()

        for cross_photo in crossing_photo:
            pictures = product.find_all(cross_photo)
            for el in pictures:
                children = el.findChildren()
                if children:
                    pass
                else:
                    photo_url = html.escape(el.get_text())
                    db.execute(f"INSERT INTO {schema_name}.picture ("
                               f"primary_key, picture) VALUES (N'{primary_key}', N'{photo_url}')")
                    conn.commit()

        for cross_param in crossing_params:
            parameters = product.find_all(cross_param)
            for param in parameters:
                attribute_param = list(param.attrs.keys())[0]
                param_name = html.escape(param.get(attribute_param))
                if param.isSelfClosing:
                    param_value = html.escape(param.next.strip())
                else:
                    param_value = (html.escape(param.next)).strip()
                db.execute(f"INSERT INTO {schema_name}.params (primary_key, param_name, param_value) "
                           f"VALUES (N'{primary_key}', N'{param_name}',  N'{param_value}')")
                conn.commit()


def pars_tags(all_products):
    all_tags = []
    for offer in all_products:
        item_number = offer.get("id")
        if item_number:
            all_tags.insert(0, 'item_id')

        for tag in offer.find_all():
            all_tags.append(tag.name)
    unit_tags = list(OrderedDict.fromkeys(all_tags))
    if "p" in unit_tags:
        unit_tags.remove('p')
    all_tags.clear()
    return unit_tags


def children_category(category, categor_tag):
    for cat_tag in category.find_all():
        categor_tag.append(cat_tag.name)


def category(soup, schema_name):
    for category_name in lst_category:
        categories = soup.find_all(category_name)
        if categories:
            categor_tag = []
            for category in categories:
                children = category.findChildren()
                if children:
                    children_category(category, categor_tag)
                else:
                    attributes_category(category, categor_tag)

            uniq_tags = list(OrderedDict.fromkeys(categor_tag))
            columns_list = [tag + ' nchar (4000)' for tag in uniq_tags]
            columns_name = ', '.join(columns_list)
            db.execute(f"create table {schema_name}.categories ("
                       f"TransactionID int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, {columns_name})")
            conn.commit()
            pars_category(categories, uniq_tags, schema_name)


def pars_category(categories, uniq_tags, schema_name):
    for category in categories:
        row = []
        children = category.findChildren()
        if children:
            for el in uniq_tags:
                data = category.find(el)
                if data:
                    row.append(html.escape(data.get_text()))
                else:
                    row.append('')
        elif not children:
            for el in uniq_tags:
                if el == "name":
                    x = category.get_text()
                    row.append(x)
                else:
                    x = category.get(el)
                    if x != None:
                        row.append(x)
                    else:
                        row.append("")
        value = ('%s, ' * len(row))[:-2]
        sql_category = f"insert into {schema_name}.categories  ({', '.join(uniq_tags)}) values ({value})"
        db.executemany(sql_category, [tuple(row)])
        conn.commit()


def attributes_category(category, categor_tag):
    for attribute in category.attrs:
        categor_tag.append(attribute)
        categor_tag.append('name')


def creating(schema_name):
    db.execute(f" CREATE SCHEMA  {schema_name} ")
    db.execute(f"create table {schema_name}.picture ("
               f"TransactionID int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
               f"primary_key nchar (100), picture nchar(1130))")
    db.execute(f"create table {schema_name}.params ("
               f"TransactionID int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, primary_key nchar (100), "
               f"param_name nchar(100), param_value nchar(4000))")
    conn.commit()


def rewrite(file, URL):
    response = requests.get(URL).content
    with open(file, "wb") as file_xml:
        file_xml.write(response)


def decider(data):
    if not data['url']:
        provider = str(data['file']).split("_")[0]
        schema_name = f"{provider}_{data['language']}"
        file = str(data['file'])
    else:
        URL = data['url']
        url_name = URL.split("/")[2].split(".")[0]
        schema_name = f"{url_name}_{data['language']}"
        file = schema_name + ".xml"
        rewrite(file, URL)
    return file, schema_name


def processing(**kwargs):
    data = kwargs['kwargs']
    funk_decider = decider(data)
    creating(funk_decider[1])
    content = open(f"media/{data['path']}").read()
    soup = BeautifulSoup(content, "xml")
    if len(soup) == 0:
        soup = BeautifulSoup(content, "lxml")
    category(soup, funk_decider[1])
    # all_products = soup.find_all(ITEM)
    # funk_tags = pars_tags(all_products)
    # item_pars(all_products, funk_decider[1], funk_tags)




